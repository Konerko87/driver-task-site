/**
 * ============================================================
 * Code.gs (FULL - DRIVER SEQ FIX - v4)
 *
 * ✅ 本版新增/修正（依你最新需求）：
 * 0) 「倉別對照」支援 4 區：北 / 中 / 雲 / 南
 * 1) getDailyTrips 回傳 warehouseRegionMap（Index 用）
 * 2) 區配司機提貨地點：吃 F（聯結到貨倉），回傳到 area.items[].pickupAddr
 * 3) 修正 E/F 單字 北/中/雲/南：顯示成 北倉/中倉/雲倉/南倉（避免 北 > 北）
 * 4) totals：北上/南下依 E 區域；區配四分區依 F 區域（areaNorth/areaMid/areaYun/areaSouth）
 * 5) ✅ 司機端（LIFF）轉運排序：改為讀「原始列」，用 姓名(轉) 尾巴數字 當 seq 排序
 *    - 例：5徐廷順1 -> seq=1
 *    - 例：5徐廷順2 -> seq=2
 *    - 沒尾碼 -> seq=null（排最後）
 * 6) 綁定：忽略數字比對；同 LINE 只能綁 1 人；同名多筆擋
 *
 * ============================================================
 */

// ===========================
// doGet router
// ===========================
function doGet(e) {
  var mode = (e && e.parameter && e.parameter.mode) ? String(e.parameter.mode) : "admin";

  // ✅ 自助綁定（JSONP）
  if (mode === "bind_jsonp") {
    var cb = (e && e.parameter && e.parameter.callback) ? String(e.parameter.callback) : "cb";
    cb = cb.replace(/[^\w.$]/g, "");

    var uid = (e && e.parameter && e.parameter.uid) ? String(e.parameter.uid).trim() : "";
    var driverName = (e && e.parameter && e.parameter.driverName) ? String(e.parameter.driverName).trim() : "";

    var payload;
    try {
      payload = bindDriverLineUserId_(uid, driverName);
      payload.ok = true;
    } catch (err) {
      payload = { ok: false, message: (err && err.message) ? err.message : String(err) };
    }

    return ContentService
      .createTextOutput(cb + "(" + JSON.stringify(payload) + ");")
      .setMimeType(ContentService.MimeType.JAVASCRIPT);
  }

  // ✅ 讀司機任務（JSONP）
  if (mode === "api_jsonp") {
    var cb2 = (e && e.parameter && e.parameter.callback) ? String(e.parameter.callback) : "cb";
    cb2 = cb2.replace(/[^\w.$]/g, "");

    var uid2 = (e && e.parameter && e.parameter.uid) ? String(e.parameter.uid).trim() : "";
    var dateTab = (e && e.parameter && e.parameter.date) ? String(e.parameter.date).trim() : "";

    var payload2;
    try {
      payload2 = getLiffDriverDaily(uid2, dateTab);
      payload2.ok = true;
    } catch (err2) {
      payload2 = { ok: false, message: (err2 && err2.message) ? err2.message : String(err2) };
    }

    return ContentService
      .createTextOutput(cb2 + "(" + JSON.stringify(payload2) + ");")
      .setMimeType(ContentService.MimeType.JAVASCRIPT);
  }

  // LIFF（保留）
  if (mode === "liff") {
    return HtmlService.createTemplateFromFile("Liff")
      .evaluate()
      .setTitle("司機今日任務")
      .setSandboxMode(HtmlService.SandboxMode.IFRAME)
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  }

  // admin
  return HtmlService.createTemplateFromFile("Index")
    .evaluate()
    .setTitle("每日車趟公告板")
    .setSandboxMode(HtmlService.SandboxMode.IFRAME)
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

function include(filename) {
  return HtmlService.createHtmlOutputFromFile(filename).getContent();
}

// ===========================
// Tabs (MMDD)
// ===========================
function getDateTabs() {
  const ss = SpreadsheetApp.getActive();
  return ss.getSheets()
    .map(s => String(s.getName()).trim())
    .filter(n => /^\d{4}$/.test(n))
    .sort((a, b) => Number(a) - Number(b));
}

// ===========================
// Date options for LIFF (D-2~D+2)
// ===========================
function getDateOptionsForLiff_() {
  const ss = SpreadsheetApp.getActive();

  const baseToday = new Date();
  const nearest = findNearestExistingDateTab_(ss, baseToday, 14);
  if (!nearest) throw new Error("找不到任何可用的 4 碼日期分頁（MMDD），且回溯 14 天也沒有。");

  const dDate = nearest.date;
  const dTab  = nearest.tab;

  const tabIfExists = (deltaDays) => {
    const dt = addDays_(dDate, deltaDays);
    const tab = mmddForTaipei_(dt);
    return ss.getSheetByName(tab) ? tab : null;
  };

  return {
    baseToday: ymdForTaipei_(baseToday),
    dMinus2: tabIfExists(-2),
    dMinus1: tabIfExists(-1),
    d: dTab,
    dPlus1: tabIfExists(1),
    dPlus2: tabIfExists(2)
  };
}

function addDays_(dateObj, deltaDays) {
  return new Date(dateObj.getTime() + deltaDays * 24 * 60 * 60 * 1000);
}
function mmddForTaipei_(dateObj) {
  return Utilities.formatDate(dateObj, "Asia/Taipei", "MMdd");
}
function ymdForTaipei_(dateObj) {
  return Utilities.formatDate(dateObj, "Asia/Taipei", "yyyy/MM/dd");
}
function findNearestExistingDateTab_(ss, baseDate, lookbackDays) {
  for (let i = 0; i <= lookbackDays; i++) {
    const dt  = addDays_(baseDate, -i);
    const tab = mmddForTaipei_(dt);
    if (ss.getSheetByName(tab)) return { tab, date: dt };
  }
  return null;
}

// ===========================
// Name normalization
// ===========================
function normalizeDriverName_(name) {
  return String(name || "")
    .trim()
    .replace(/\s+/g, "")
    .replace(/[0-9０-９]/g, "")
    .toLowerCase();
}
function cleanDriverDisplay_(name) {
  return String(name || "")
    .trim()
    .replace(/\s+/g, "")
    .replace(/[0-9０-９]/g, "");
}
function normalizeNameCJK_(name) {
  const s = String(name || "")
    .trim()
    .replace(/\s+/g, "")
    .replace(/[0-9０-９]/g, "");
  const onlyCjk = (s.match(/[\u3400-\u9FFF]+/g) || []).join("");
  return onlyCjk;
}

// ===========================
// Warehouse display cleanup (E/F 顯示修正)
// ===========================
function cleanWarehouseDisplay_(s) {
  const v = String(s || "").trim();
  if (!v) return "";
  if (v === "北") return "北倉";
  if (v === "中") return "中倉";
  if (v === "雲") return "雲倉";
  if (v === "南") return "南倉";
  return v;
}

// ===========================
// 倉別對照：分頁「倉別對照」
// - A: 倉別代碼/名稱
// - B: 區域（北/中/雲/南）
// ===========================
function normalizeWarehouseKey_(s) {
  return String(s || "").trim().replace(/\s+/g, "").toLowerCase();
}

function getWarehouseRegionMap_() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName("倉別對照");
  if (!sh) return {};

  const values = sh.getDataRange().getValues();
  if (!values || values.length === 0) return {};

  const map = {};
  let startRow = 0;

  // 若第一列像表頭就跳過
  const h0 = String(values[0][0] || "").trim();
  const h1 = String(values[0][1] || "").trim();
  if (h0.includes("倉") || h1.includes("區")) startRow = 1;

  for (let i = startRow; i < values.length; i++) {
    const code = String(values[i][0] || "").trim();
    const region = String(values[i][1] || "").trim();
    if (!code || !region) continue;

    const key = normalizeWarehouseKey_(code);
    if (!key) continue;

    if (region === "北" || region === "中" || region === "雲" || region === "南") {
      map[key] = region;
    }
  }
  return map;
}

function regionOfWarehouse_(raw, map) {
  const s = String(raw || "").trim();
  if (!s) return "不明";

  const key = normalizeWarehouseKey_(s);
  if (map && map[key]) return map[key];

  // fuzzy contains
  if (map) {
    for (var k in map) {
      if (!k) continue;
      if (key.includes(k)) return map[k];
    }
  }

  // fallback
  if (s.includes("北")) return "北";
  if (s.includes("中")) return "中";
  if (s.includes("雲")) return "雲";
  if (s.includes("南")) return "南";
  return "不明";
}

// ===========================
// Parse tail seq only (轉運/區配都共用)
// ===========================
function parseNameWithTailSeqOnly_(raw) {
  const s0 = String(raw || "").trim().replace(/\s+/g, "");
  if (!s0) return { name: "", seq: null };

  const s = s0.replace(/[０-９]/g, ch => String(ch.charCodeAt(0) - 0xFF10));

  const m = s.match(/^(.*?)(\d+)$/);
  if (!m) return { name: s0, seq: null };

  const namePart = String(m[1] || "");
  const seq = Number(m[2]);
  return { name: namePart || s0, seq: Number.isFinite(seq) ? seq : null };
}

// ===========================
// Driver binding: sheet「司機對照」
// header: driverName | lineUserId | enabled
// ===========================
function bindDriverLineUserId_(lineUserId, driverName) {
  const uid = String(lineUserId || "").trim();
  const name = String(driverName || "").trim();

  if (!uid) throw new Error("缺少 lineUserId（LIFF 未取到 userId）");
  if (!name) throw new Error("請輸入姓名（系統會忽略姓名中的數字）");

  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName("司機對照");
  if (!sh) throw new Error("找不到分頁：司機對照");

  const values = sh.getDataRange().getValues();
  if (!values || values.length < 2) throw new Error("司機對照沒有資料（至少要有表頭與一筆以上）");

  const header = values[0].map(x => String(x || "").trim());
  const idxName = header.indexOf("driverName");
  const idxUid  = header.indexOf("lineUserId");
  const idxEn   = header.indexOf("enabled");
  if (idxName < 0 || idxUid < 0 || idxEn < 0) {
    throw new Error("司機對照表頭需包含：driverName, lineUserId, enabled");
  }

  const inputNorm = normalizeDriverName_(name);

  // uid 是否已綁其他人
  for (let i = 1; i < values.length; i++) {
    const row = values[i];
    const rowUid = String(row[idxUid] || "").trim();
    const rowName = String(row[idxName] || "").trim();
    const enabled = String(row[idxEn] || "").trim().toUpperCase();

    if (rowUid === uid && enabled === "TRUE") {
      const rowNorm = normalizeDriverName_(rowName);
      if (rowNorm && rowNorm !== inputNorm) {
        throw new Error("此 LINE 已綁定其他司機：" + cleanDriverDisplay_(rowName) + "（如需更換請聯絡管理員）");
      }
    }
  }

  // 找姓名（忽略數字）
  let matches = [];
  for (let i = 1; i < values.length; i++) {
    const rowName = String(values[i][idxName] || "").trim();
    const rowNorm = normalizeDriverName_(rowName);
    if (rowNorm && rowNorm === inputNorm) {
      matches.push({
        rowIndex: i + 1,
        rowName: rowName,
        existingUid: String(values[i][idxUid] || "").trim()
      });
    }
  }

  if (matches.length === 0) {
    throw new Error("找不到此姓名（系統會忽略數字比對）。請確認調度已在「司機對照」建立你的姓名。");
  }
  if (matches.length > 1) {
    const list = matches.map(x => cleanDriverDisplay_(x.rowName)).join("、");
    throw new Error("同名（忽略數字）有多筆，請聯絡管理員指定正確姓名：" + list);
  }

  const m = matches[0];

  if (m.existingUid && m.existingUid !== uid) {
    throw new Error("此姓名已綁定其他 LINE（如需更換請聯絡管理員）");
  }

  sh.getRange(m.rowIndex, idxUid + 1).setValue(uid);
  sh.getRange(m.rowIndex, idxEn + 1).setValue("TRUE");

  return {
    message: "綁定成功",
    driverName: cleanDriverDisplay_(m.rowName),
    driverNameRaw: m.rowName,
    lineUserId: uid
  };
}

// ===========================
// LIFF daily payload: returns `me`
// ✅ 轉運使用「原始列」與 B 尾碼 seq 排序
// ===========================
function getLiffDriverDaily(lineUserId, dateTab) {
  if (!lineUserId) throw new Error("缺少 lineUserId（LIFF 未取到 userId）");

  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName("司機對照");
  if (!sh) throw new Error("找不到分頁：司機對照（需 driverName/lineUserId/enabled）");

  const values = sh.getDataRange().getValues();
  if (!values || values.length < 2) throw new Error("司機對照沒有資料");

  const header = values[0].map(x => String(x || "").trim());
  const idxName = header.indexOf("driverName");
  const idxUid  = header.indexOf("lineUserId");
  const idxEn   = header.indexOf("enabled");
  if (idxName < 0 || idxUid < 0 || idxEn < 0) {
    throw new Error("司機對照表頭需包含：driverName, lineUserId, enabled");
  }

  const uid = String(lineUserId).trim();
  let driverNameRaw = null;

  for (let i = 1; i < values.length; i++) {
    const rowUid = String(values[i][idxUid] || "").trim();
    const enabled = String(values[i][idxEn] || "").trim().toUpperCase();
    if (rowUid === uid && enabled === "TRUE") {
      driverNameRaw = String(values[i][idxName] || "").trim();
      break;
    }
  }

  if (!driverNameRaw) {
    throw new Error("此 LINE 尚未綁定司機（或 enabled 不是 TRUE）。請在畫面內輸入姓名完成綁定。");
  }

  const opt = getDateOptionsForLiff_();

  let chosen = opt.d;
  if (dateTab && /^\d{4}$/.test(String(dateTab))) {
    const dt = String(dateTab).trim();
    if (!ss.getSheetByName(dt)) throw new Error("找不到分頁：" + dt);
    chosen = dt;
  }

  // 司機端要：原始列（含轉運 seq） + 你原本的 daily（保留除錯）
  const rawPack = readRowsForLiff_(chosen);
  const daily = getDailyTrips(chosen);

  const me = buildMeFromRows_(driverNameRaw, rawPack.rows);

  return {
    driverName: me.driverName,
    chosenDate: chosen,
    options: opt,
    daily,     // 保留除錯
    me
  };
}

// 司機端專用：直接讀原始列（不合併）以保留 seq
function readRowsForLiff_(tabName) {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(String(tabName).trim());
  if (!sh) throw new Error("找不到分頁：" + tabName);

  const values = sh.getDataRange().getValues();
  if (!values || values.length < 2) return { rows: [] };

  const headers = values[0].map(x => String(x || "").trim());
  const col = buildColumnMap_(headers);

  const rowsRaw = values.slice(1).filter(r => r.some(c => String(c || "").trim() !== ""));

  const rows = [];
  for (const r of rowsRaw) {
    const row = normalizeRowForLiff_(r, col);
    if (row) rows.push(row);
  }
  return { rows };
}

// 司機端 row：保留 transferSeq（姓名(轉) 尾巴） + areaSeq（姓名(區) 尾巴）
function normalizeRowForLiff_(r, col) {
  const get = (i) => (i == null || i < 0) ? "" : String(r[i] ?? "").trim();

  const pickupRaw  = get(col.pickup);
  const dropoffRaw = get(col.dropoff);

  const pickup  = cleanWarehouseDisplay_(pickupRaw);
  const dropoff = cleanWarehouseDisplay_(dropoffRaw);

  const driverTransferRaw = get(col.driverTransfer);
  const driverAreaRaw     = get(col.driverArea);

  const transferParsed = parseNameWithTailSeqOnly_(driverTransferRaw);
  const areaParsed     = parseNameWithTailSeqOnly_(driverAreaRaw);

  const transferDriver = cleanDriverDisplay_(transferParsed.name);
  const transferSeq    = transferParsed.seq;

  const areaDriver = cleanDriverDisplay_(areaParsed.name);
  const areaSeq    = areaParsed.seq;

  const receiver = get(col.receiver);
  const owner    = get(col.owner);
  const carNo    = get(col.carNo);
  const note     = get(col.note);

  // 區配提貨地點：F（到貨倉）
  const areaPickupAddr = cleanWarehouseDisplay_(get(col.dropoff));
  const areaDropAddr   = get(col.areaDropAddr);

  // boards
  let boards = 0;
  const bRaw = (col.boards >= 0) ? r[col.boards] : 0;
  if (typeof bRaw === "number") boards = bRaw;
  else boards = Number(String(bRaw || "").replace(/[^\d.\-]/g, "") || 0);
  if (!isFinite(boards)) boards = 0;

  // grade
  let grade = get(col.grade).toUpperCase().replace(/\s+/g, "");
  if (grade === "A") grade = "S";
  if (grade !== "H" && grade !== "S") grade = "S";

  const hasAny = pickup || dropoff || transferDriver || areaDriver || receiver || owner || boards !== 0;
  if (!hasAny) return null;

  return {
    pickup, dropoff,
    boards, grade,
    owner, carNo, note,
    receiver,
    transferDriver, transferSeq,
    areaDriver, areaSeq,
    areaPickupAddr,
    areaDropAddr
  };
}

// 司機端：用原始列組 me（轉運依 transferSeq 排序、區配依 areaSeq 排序）
function buildMeFromRows_(driverNameRaw, rows) {
  const meNorm = normalizeNameCJK_(driverNameRaw);

  const transfer = [];
  const area = [];

  for (const r of (rows || [])) {
    if (normalizeNameCJK_(r.transferDriver) === meNorm) {
      transfer.push({
        pickup: r.pickup,
        dropoff: r.dropoff,
        boards: r.boards,
        grade: r.grade,
        owner: r.owner || "",
        carNo: r.carNo || "",
        note: r.note || "",
        seq: (r.transferSeq === null || r.transferSeq === undefined) ? null : Number(r.transferSeq)
      });
    }

    if (normalizeNameCJK_(r.areaDriver) === meNorm) {
      area.push({
        pickup: r.pickup,
        dropoff: r.dropoff,
        dropLabel: r.receiver || "",
        receiver: r.receiver || "",
        pickupAddr: r.areaPickupAddr || "",
        recvAddr: r.areaDropAddr || "",
        boards: r.boards,
        grade: r.grade,
        owner: r.owner || "",
        carNo: r.carNo || "",
        note: r.note || "",
        seq: (r.areaSeq === null || r.areaSeq === undefined) ? null : Number(r.areaSeq)
      });
    }
  }

  transfer.sort((a,b)=>{
    const sa = (a.seq === null || a.seq === undefined) ? 999999 : Number(a.seq);
    const sb = (b.seq === null || b.seq === undefined) ? 999999 : Number(b.seq);
    if (sa !== sb) return sa - sb;
    return Number(b.boards||0) - Number(a.boards||0);
  });

  area.sort((a,b)=>{
    const sa = (a.seq === null || a.seq === undefined) ? 999999 : Number(a.seq);
    const sb = (b.seq === null || b.seq === undefined) ? 999999 : Number(b.seq);
    if (sa !== sb) return sa - sb;
    return Number(b.boards||0) - Number(a.boards||0);
  });

  const me = {
    driverName: cleanDriverDisplay_(driverNameRaw),
    driverNameRaw: driverNameRaw,
    driverNameNorm: meNorm,
    transfer: {
      count: transfer.length,
      totalBoards: transfer.reduce((s,x)=>s+Number(x.boards||0),0),
      items: transfer
    },
    area: {
      count: area.length,
      totalBoards: area.reduce((s,x)=>s+Number(x.boards||0),0),
      items: area
    }
  };
  me.hasTasks = (transfer.length + area.length) > 0;
  return me;
}

// ===========================
// getDailyTrips(tabName) for Index
// ===========================
function getDailyTrips(tabName) {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(String(tabName).trim());
  if (!sh) throw new Error("找不到分頁：" + tabName);

  const values = sh.getDataRange().getValues();
  if (!values || values.length < 2) {
    return {
      date: tabName,
      totals: {
        totalBoards: 0, north: 0, south: 0, area: 0, unknown: 0,
        transferTotal: 0, localTotal: 0,
        areaNorth: 0, areaMid: 0, areaYun: 0, areaSouth: 0
      },
      block1: { pickupToDropAll: [] },
      block2: { transferDrivers: [], areaDrivers: [] },
      warehouseRegionMap: getWarehouseRegionMap_()
    };
  }

  const headers = values[0].map(x => String(x || "").trim());
  const rowsRaw = values.slice(1).filter(r => r.some(c => String(c || "").trim() !== ""));

  const col = buildColumnMap_(headers);

  const rows = rowsRaw
    .map(r => normalizeRow_(r, col))
    .filter(Boolean);

  const pickupToDropAll = pivotPickupToDropWithOwners_(rows);
  const transferDrivers = groupByTransferDriver_(rows);
  const areaDrivers = groupByAreaDriver_(rows);

  const totals = buildTotals_(pickupToDropAll, rows);

  return {
    date: tabName,
    totals,
    block1: { pickupToDropAll },
    block2: { transferDrivers, areaDrivers },
    warehouseRegionMap: getWarehouseRegionMap_()
  };
}

// ===========================
// Column mapping (Index + LIFF 共用)
// ===========================
function buildColumnMap_(headers) {
  const idxByName = {};
  headers.forEach((h, i) => { idxByName[String(h || "").trim()] = i; });

  const must = (name) => {
    const i = idxByName[name];
    return (i === undefined) ? -1 : i;
  };

  return {
    pickup:  must("聯結提貨倉"),        // E
    dropoff: must("聯結到貨倉"),        // F
    boards:  must("板數"),

    driverTransfer: must("姓名(轉)"),   // B
    driverArea:     must("姓名(區)"),

    grade:    must("配送等級 H / A"),
    carNo:    must("車號"),
    note:     must("出庫單備註"),
    owner:    must("貨主"),
    receiver: must("收件人姓名"),

    // 區配收件人地址（I）
    areaDropAddr: must("區配收件人地址")
  };
}

// ===========================
// Row normalize (Index 用：合併顯示仍走這裡)
// ===========================
function normalizeRow_(r, col) {
  const get = (i) => (i == null || i < 0) ? "" : String(r[i] ?? "").trim();

  const pickup  = cleanWarehouseDisplay_(get(col.pickup));
  const dropoff = cleanWarehouseDisplay_(get(col.dropoff));

  const driverTransferRaw = get(col.driverTransfer);
  const driverAreaRaw = get(col.driverArea);

  const receiver = get(col.receiver);
  const owner   = get(col.owner);
  const carNo   = get(col.carNo);
  const note    = get(col.note);

  // 區配提貨地點：F
  const areaPickupAddr = cleanWarehouseDisplay_(get(col.dropoff));
  const areaDropAddr   = get(col.areaDropAddr);

  // boards
  let boards = 0;
  const bRaw = (col.boards >= 0) ? r[col.boards] : 0;
  if (typeof bRaw === "number") boards = bRaw;
  else boards = Number(String(bRaw || "").replace(/[^\d.\-]/g, "") || 0);
  if (!isFinite(boards)) boards = 0;

  // grade
  let grade = get(col.grade).toUpperCase().replace(/\s+/g, "");
  if (grade === "A") grade = "S";
  if (grade !== "H" && grade !== "S") grade = "S";

  // area seq: tail digits only
  const areaParsed = parseNameWithTailSeqOnly_(driverAreaRaw);
  const areaDriver = cleanDriverDisplay_(areaParsed.name);
  const areaSeq = areaParsed.seq;

  const transferParsed = parseNameWithTailSeqOnly_(driverTransferRaw);
  const transferDriver = cleanDriverDisplay_(transferParsed.name);

  const hasAny =
    pickup || dropoff || transferDriver || areaDriver || receiver || owner || boards !== 0;
  if (!hasAny) return null;

  return {
    pickup, dropoff,
    owner, carNo, note, grade, boards,
    receiver,

    transferDriver,

    areaDriverRaw: driverAreaRaw,
    areaDriver,
    areaSeq,

    areaPickupAddr,
    areaDropAddr
  };
}

// ===========================
// Pivot announce: pickup -> drops + owner breakdown
// ===========================
function pivotPickupToDropWithOwners_(rows) {
  const map = new Map();

  rows.forEach(row => {
    const pickup = row.pickup || "";
    if (!pickup) return;

    const drop  = row.dropoff || "";
    const owner = row.owner || "";
    const b     = Number(row.boards || 0);

    if (!map.has(pickup)) {
      map.set(pickup, { pickup, subtotal: 0, dropMap: {}, ownerMap: {}, ownerDropMap: {} });
    }

    const g = map.get(pickup);
    g.subtotal += b;

    if (drop) g.dropMap[drop] = (g.dropMap[drop] || 0) + b;

    const ownerKey = owner || "(未填貨主)";
    g.ownerMap[ownerKey] = (g.ownerMap[ownerKey] || 0) + b;
    if (!g.ownerDropMap[ownerKey]) g.ownerDropMap[ownerKey] = {};
    if (drop) g.ownerDropMap[ownerKey][drop] = (g.ownerDropMap[ownerKey][drop] || 0) + b;
  });

  const out = Array.from(map.values()).map(g => {
    const items = Object.entries(g.dropMap)
      .map(([dropoff, boards]) => ({ dropoff, boards }))
      .sort((a, b) => Number(b.boards) - Number(a.boards));

    const ownerItems = Object.entries(g.ownerMap)
      .map(([owner, boards]) => ({ owner, boards }))
      .sort((a, b) => Number(b.boards) - Number(a.boards));

    const ownerDropItems = Object.keys(g.ownerDropMap).map(owner => {
      const dropsObj = g.ownerDropMap[owner] || {};
      const drops = Object.entries(dropsObj)
        .map(([dropoff, boards]) => ({ dropoff, boards }))
        .sort((a, b) => Number(b.boards) - Number(a.boards));
      const totalBoards = drops.reduce((s, x) => s + Number(x.boards || 0), 0);
      return { owner, totalBoards, drops };
    }).sort((a, b) => Number(b.totalBoards) - Number(a.totalBoards));

    return { pickup: g.pickup, subtotal: g.subtotal, items, ownerItems, ownerDropItems };
  });

  out.sort((a, b) => Number(b.subtotal) - Number(a.subtotal));
  return out;
}

// ===========================
// Group: transfer driver (Index 用：合併同路徑)
// ===========================
function groupByTransferDriver_(rows) {
  const driverMap = new Map();

  for (const r of rows) {
    const driver = String(r.transferDriver || "").trim();
    if (!driver) continue;

    if (!driverMap.has(driver)) driverMap.set(driver, { driver, agg: new Map() });
    const d = driverMap.get(driver);

    const pickup = r.pickup || "";
    const dropoff = r.dropoff || "";
    const key = pickup + "||" + dropoff;

    if (!d.agg.has(key)) {
      d.agg.set(key, {
        pickup, dropoff,
        boards: 0,
        grade: "S",
        ownerSet: new Set(),
        carSet: new Set(),
        noteSet: new Set()
      });
    }

    const a = d.agg.get(key);
    a.boards += Number(r.boards || 0);
    if (r.grade === "H") a.grade = "H";
    if (r.owner) a.ownerSet.add(String(r.owner));
    if (r.carNo) a.carSet.add(String(r.carNo));
    if (r.note)  a.noteSet.add(String(r.note));
  }

  const result = [];
  for (const [driver, d] of driverMap.entries()) {
    const items = Array.from(d.agg.values()).map(x => ({
      pickup: x.pickup,
      dropoff: x.dropoff,
      boards: x.boards,
      grade: x.grade,
      owner: Array.from(x.ownerSet).join(" / "),
      carNo: Array.from(x.carSet).join(" / "),
      note: Array.from(x.noteSet).join(" / ")
    })).sort((a, b) => Number(b.boards) - Number(a.boards));

    const totalBoards = items.reduce((s, x) => s + Number(x.boards || 0), 0);
    result.push({ driver: cleanDriverDisplay_(driver), count: items.length, totalBoards, items });
  }

  result.sort((a, b) => Number(b.totalBoards) - Number(a.totalBoards));
  return result;
}

// ===========================
// Group: area driver (Index 用)
// ===========================
function groupByAreaDriver_(rows) {
  const driverMap = new Map();

  for (const r of rows) {
    const driver = String(r.areaDriver || "").trim();
    if (!driver) continue;

    if (!driverMap.has(driver)) driverMap.set(driver, { driver, items: [] });
    const d = driverMap.get(driver);

    d.items.push({
      pickup: r.pickup || "",
      dropoff: r.dropoff || "",
      dropLabel: r.receiver || "",
      receiver: r.receiver || "",
      pickupAddr: r.dropoff || "",      // ✅ 區配提貨地點顯示 F
      recvAddr: r.areaDropAddr || "",
      seq: (r.areaSeq === null || r.areaSeq === undefined) ? null : Number(r.areaSeq),
      grade: r.grade || "S",
      boards: Number(r.boards || 0),
      owner: r.owner || "",
      carNo: r.carNo || "",
      note: r.note || ""
    });
  }

  const result = [];
  for (const [driver, d] of driverMap.entries()) {
    const totalBoards = (d.items || []).reduce((s, x) => s + Number(x.boards || 0), 0);
    result.push({
      driver: cleanDriverDisplay_(driver),
      count: (d.items || []).length,
      totalBoards,
      items: d.items || []
    });
  }

  result.sort((a, b) => Number(b.totalBoards) - Number(a.totalBoards));
  return result;
}

// ===========================
// Totals (Index KPI 用)
// ===========================
function buildTotals_(pickupToDropAll, rows) {
  const whMap = getWarehouseRegionMap_();

  const totalBoards = (pickupToDropAll || []).reduce((s, x) => s + Number(x.subtotal || 0), 0);

  let transferTotal = 0;
  let localTotal = 0;

  // 北上/南下（看 E 區域）
  let north = 0; // 北上
  let south = 0; // 南下

  // 區配四類（看 F 區域）
  let areaNorth = 0; // 北區配
  let areaMid   = 0; // 中區配
  let areaYun   = 0; // 雲區配
  let areaSouth = 0; // 南區配

  let unknown = 0;

  (rows || []).forEach(r => {
    const b = Number(r.boards || 0);

    if (r.transferDriver) transferTotal += b;

    if (r.areaDriver) {
      localTotal += b;

      const toR = regionOfWarehouse_(r.dropoff, whMap); // F
      if (toR === "北") areaNorth += b;
      else if (toR === "中") areaMid += b;
      else if (toR === "雲") areaYun += b;
      else if (toR === "南") areaSouth += b;
    }

    const fromR = regionOfWarehouse_(r.pickup, whMap); // E
    if (fromR === "北") south += b; // 北出發 -> 南下
    else if (fromR === "南" || fromR === "中" || fromR === "雲") north += b; // 南/中/雲出發 -> 北上
    else unknown += b;
  });

  return {
    totalBoards,
    north,
    south,
    area: localTotal,
    unknown: Math.max(0, totalBoards - (north + south)), // 依你現規則：E 能判斷就不算 unknown
    transferTotal,
    localTotal,
    areaNorth,
    areaMid,
    areaYun,
    areaSouth
  };
}


